const { FinancialUpload, CategoryAverage, CategorizedTransaction, CombinedUpload } = require("../../../db/agentDB");
const { calculateMonthlyAverages, getBucket } = require("./financialAnalyzer");
const { getDateRange } = require("./csvParser");

/**
 * Format a date to YYYY-MM-DD string
 * @param {Date|string} date - Date to format
 * @returns {string} Formatted date string
 */
function formatDate(date) {
  if (!date) return '';
  const d = new Date(date);
  return d.toISOString().split('T')[0];
}

/**
 * Combine multiple financial uploads into a unified analysis
 * @param {number} userId - Agent user ID
 * @param {Array<number>} uploadIds - Array of FinancialUpload IDs to combine
 * @param {string} name - Optional name for the combined upload
 * @param {boolean} isAutoGenerated - Whether this was auto-created from multi-file upload
 * @returns {Promise<Object>} Combined upload record with analysis
 */
async function combineUploads(userId, uploadIds, name = null, isAutoGenerated = false) {
  console.log("\n=== COMBINING UPLOADS ===");
  console.log(`User ID: ${userId}`);
  console.log(`Upload IDs to combine: ${uploadIds.join(", ")}`);
  console.log(`Name: ${name || "(auto-generated)"}`);
  console.log(`Is auto-generated: ${isAutoGenerated}`);

  if (!uploadIds || uploadIds.length < 2) {
    throw new Error("Must provide at least 2 uploads to combine");
  }

  // Fetch all uploads with their transactions
  const uploads = await FinancialUpload.findAll({
    where: {
      id: uploadIds,
      userId,
      status: "completed",
    },
    include: [
      {
        model: CategorizedTransaction,
        as: "categorizedTransactions",
      },
    ],
  });

  console.log(`\n[STEP 1] Found ${uploads.length} uploads`);

  if (uploads.length !== uploadIds.length) {
    console.error(`ERROR: Expected ${uploadIds.length} uploads but found ${uploads.length}`);
    throw new Error("One or more uploads not found or not accessible");
  }

  // Debug: Check if transactions exist in database
  for (const [idx, upload] of uploads.entries()) {
    console.log(`  Upload ${idx + 1}: ${upload.filename}`);
    console.log(`    - ID: ${upload.id}`);
    console.log(`    - Transactions in DB: ${upload.totalTransactions}`);
    console.log(`    - Categorized transactions loaded: ${upload.categorizedTransactions?.length || 0}`);

    // Direct query to verify data exists
    const directCount = await CategorizedTransaction.count({ where: { uploadId: upload.id } });
    console.log(`    - Direct count query result: ${directCount}`);
  }

  // Collect all transactions from all uploads
  const allTransactions = [];
  const sourceBreakdown = [];

  console.log(`\n[STEP 2] Collecting transactions from all uploads`);

  for (const upload of uploads) {
    const transactions = upload.categorizedTransactions || [];

    console.log(`  Processing ${upload.filename || `Upload ${upload.id}`}:`);
    console.log(`    - Found ${transactions.length} categorized transactions`);

    // Add to combined list
    const mappedTransactions = transactions.map(txn => ({
      date: txn.date,
      description: txn.description,
      amount: txn.rawAmount,
      normalizedAmount: txn.normalizedAmount,
      absAmount: txn.absAmount,
      source: txn.source,
      category: txn.category,
      bucket: txn.bucket,
      sourceFile: upload.filename || `Upload ${upload.id}`,
    }));

    allTransactions.push(...mappedTransactions);
    console.log(`    - Added ${mappedTransactions.length} transactions to combined list`);

    // Calculate per-source breakdown
    const sourceTotal = transactions.length > 0
      ? transactions.reduce((sum, txn) => sum + parseFloat(txn.absAmount || 0), 0)
      : 0;
    console.log(`    - Source total: $${Number(sourceTotal).toFixed(2)}`);

    sourceBreakdown.push({
      uploadId: upload.id,
      filename: upload.filename || `Upload ${upload.id}`,
      transactionCount: transactions.length,
      totalAmount: sourceTotal,
      dateRange: `${formatDate(upload.startDate)} to ${formatDate(upload.endDate)}`,
      monthCount: upload.monthCount,
      monthlyAverage: sourceTotal / upload.monthCount,
    });
  }

  console.log(`\n[STEP 3] Total combined transactions: ${allTransactions.length}`);

  // Calculate combined date range from transaction dates OR upload date ranges
  let startDate, endDate;

  if (allTransactions.length > 0) {
    const dates = allTransactions.map(txn => new Date(txn.date)).sort((a, b) => a - b);
    startDate = dates[0];
    endDate = dates[dates.length - 1];
  } else {
    // Fallback: use upload date ranges if no transactions
    const uploadDates = uploads.flatMap(u => [new Date(u.startDate), new Date(u.endDate)]).sort((a, b) => a - b);
    startDate = uploadDates[0];
    endDate = uploadDates[uploadDates.length - 1];
  }

  const daysDifference = (endDate - startDate) / (1000 * 60 * 60 * 24);
  const monthCountRaw = daysDifference / 30;
  const monthCount = Math.max(1, Math.round(monthCountRaw));

  // Calculate combined totals
  const categoryTotals = {};
  const bucketTotals = {};

  for (const txn of allTransactions) {
    if (!categoryTotals[txn.category]) {
      categoryTotals[txn.category] = 0;
    }
    // Ensure we're working with numbers
    const absAmount = parseFloat(txn.absAmount) || 0;
    categoryTotals[txn.category] += absAmount;

    if (!bucketTotals[txn.bucket]) {
      bucketTotals[txn.bucket] = 0;
    }
    bucketTotals[txn.bucket] += absAmount;
  }

  // Ensure grandTotal is always a valid number
  const grandTotal = Object.values(categoryTotals).length > 0
    ? Object.values(categoryTotals).reduce((sum, val) => sum + parseFloat(val || 0), 0)
    : 0;
  const totalMonthlyAverage = grandTotal / monthCount;

  console.log(`\n[STEP 4] Calculation Summary:`);
  console.log(`  - Category totals object:`, categoryTotals);
  console.log(`  - Grand total type:`, typeof grandTotal);
  console.log(`  - Grand total value:`, grandTotal);
  console.log(`  - Grand total: $${Number(grandTotal).toFixed(2)}`);
  console.log(`  - Month count: ${monthCount}`);
  console.log(`  - Monthly average: $${Number(totalMonthlyAverage).toFixed(2)}`);

  // Calculate per-category monthly averages
  const categoryAverages = {};
  for (const [category, total] of Object.entries(categoryTotals)) {
    categoryAverages[category] = total / monthCount;
  }

  const bucketAverages = {};
  for (const [bucket, total] of Object.entries(bucketTotals)) {
    bucketAverages[bucket] = total / monthCount;
  }

  // Generate default name if not provided
  const combinedName = name || `Combined: ${uploads.map(u => u.filename || `Upload ${u.id}`).join(", ").substring(0, 100)}`;

  // Create calculation log
  const calculationLog = {
    dateRange: {
      firstTransactionDate: startDate.toISOString().split("T")[0],
      lastTransactionDate: endDate.toISOString().split("T")[0],
      daysBetween: Math.round(daysDifference),
      monthCountFormula: `${Math.round(daysDifference)} days / 30 = ${monthCountRaw.toFixed(2)} â†’ rounded to ${monthCount}`,
      monthCountUsed: monthCount,
    },
    totals: {
      grandTotal,
      monthCount,
      formula: `${grandTotal.toFixed(2)} / ${monthCount} = ${totalMonthlyAverage.toFixed(2)}`,
    },
    sources: sourceBreakdown,
    combinedFrom: uploadIds,
  };

  // Create combined upload record
  const combined = await CombinedUpload.create({
    userId,
    name: combinedName,
    uploadIds,
    monthCount,
    startDate: startDate.toISOString().split("T")[0],
    endDate: endDate.toISOString().split("T")[0],
    totalTransactions: allTransactions.length,
    totalMonthlyAverage: Number(totalMonthlyAverage.toFixed(2)),
    sourceBreakdown,
    calculationLog,
    isAutoGenerated,
  });

  console.log(`\n[STEP 5] Created combined upload record:`);
  console.log(`  - Combined ID: ${combined.id}`);
  console.log(`  - Name: ${combinedName}`);
  console.log(`  - Total transactions: ${allTransactions.length}`);
  console.log(`  - Monthly average: $${totalMonthlyAverage.toFixed(2)}`);
  console.log(`=== COMBINATION COMPLETE ===\n`);

  return {
    combinedId: combined.id,
    name: combinedName,
    summary: {
      dateRange: `${formatDate(combined.startDate)} to ${formatDate(combined.endDate)}`,
      monthCount,
      totalTransactions: allTransactions.length,
      totalMonthlyAverage: parseFloat(totalMonthlyAverage.toFixed(2)),
      sourceCount: uploads.length,
    },
    averages: {
      byCategory: Object.fromEntries(
        Object.entries(categoryAverages).map(([cat, avg]) => [cat, parseFloat(avg.toFixed(2))])
      ),
      byBucket: Object.fromEntries(
        Object.entries(bucketAverages).map(([bucket, avg]) => [bucket, parseFloat(avg.toFixed(2))])
      ),
    },
    sourceBreakdown,
    calculationLog,
  };
}

/**
 * Get details for a combined upload
 * @param {number} combinedId - Combined upload ID
 * @param {number} userId - Agent user ID (for authorization)
 * @returns {Promise<Object>} Detailed combined upload results
 */
async function getCombinedDetails(combinedId, userId) {
  const combined = await CombinedUpload.findOne({
    where: { id: combinedId, userId },
  });

  if (!combined) {
    throw new Error("Combined upload not found");
  }

  // Fetch all individual uploads for additional details
  const uploads = await FinancialUpload.findAll({
    where: {
      id: combined.uploadIds,
      userId,
    },
  });

  // Group averages by bucket
  const bucketSummary = {};
  const calculationLog = combined.calculationLog || {};
  const averages = calculationLog.averages || { byCategory: {}, byBucket: {} };

  // Re-aggregate by category and bucket from source uploads
  const allCategoryAverages = await CategoryAverage.findAll({
    where: {
      uploadId: combined.uploadIds,
    },
  });

  const categoryTotals = {};
  for (const cat of allCategoryAverages) {
    const category = cat.category;
    const bucket = cat.bucket;

    if (!categoryTotals[category]) {
      categoryTotals[category] = {
        totalAmount: 0,
        transactionCount: 0,
        bucket,
      };
    }
    categoryTotals[category].totalAmount += parseFloat(cat.totalAmount);
    categoryTotals[category].transactionCount += cat.transactionCount;
  }

  // Group by bucket
  for (const [category, data] of Object.entries(categoryTotals)) {
    const bucket = data.bucket;
    const monthlyAvg = data.totalAmount / combined.monthCount;

    if (!bucketSummary[bucket]) {
      bucketSummary[bucket] = {
        total: 0,
        categories: [],
      };
    }
    bucketSummary[bucket].total += monthlyAvg;
    bucketSummary[bucket].categories.push({
      category,
      monthlyAverage: parseFloat(monthlyAvg.toFixed(2)),
      transactionCount: data.transactionCount,
    });
  }

  // Calculate aggregate counts from individual uploads
  const totalCategorized = uploads.reduce((sum, u) => sum + (u.categorizedCount || 0), 0);
  const totalUncategorized = uploads.reduce((sum, u) => sum + (u.uncategorizedCount || 0), 0);
  const totalExcluded = uploads.reduce((sum, u) => sum + (u.excludedCount || 0), 0);

  return {
    upload: {
      id: combined.id,
      name: combined.name,
      createdAt: combined.createdAt,
      dateRange: `${formatDate(combined.startDate)} to ${formatDate(combined.endDate)}`,
      monthCount: combined.monthCount,
      totalTransactions: combined.totalTransactions,
      categorizedCount: totalCategorized,
      uncategorizedCount: totalUncategorized,
      excludedCount: totalExcluded,
      totalMonthlyAverage: parseFloat(combined.totalMonthlyAverage),
      isAutoGenerated: combined.isAutoGenerated,
      sourceCount: combined.uploadIds.length,
    },
    buckets: bucketSummary,
    calculationLog: combined.calculationLog,
    sourceBreakdown: combined.sourceBreakdown || [],
    individualUploads: uploads.map(u => ({
      id: u.id,
      filename: u.filename,
      dateRange: `${u.startDate} to ${u.endDate}`,
      monthCount: u.monthCount,
      totalTransactions: u.totalTransactions,
      totalMonthlyAverage: parseFloat(u.totalMonthlyAverage),
    })),
  };
}

/**
 * Get all transactions from a combined upload
 * @param {number} combinedId - Combined upload ID
 * @param {number} userId - Agent user ID
 * @returns {Promise<Object>} Transaction breakdown with source info
 */
async function getCombinedTransactions(combinedId, userId) {
  const combined = await CombinedUpload.findOne({
    where: { id: combinedId, userId },
  });

  if (!combined) {
    throw new Error("Combined upload not found");
  }

  // Fetch all transactions from all source uploads
  const transactions = await CategorizedTransaction.findAll({
    where: {
      uploadId: combined.uploadIds,
    },
    order: [["date", "DESC"]],
    include: [
      {
        model: FinancialUpload,
        as: "upload",
        attributes: ["id", "filename"],
      },
    ],
  });

  return {
    upload: {
      id: combined.id,
      name: combined.name,
      dateRange: `${formatDate(combined.startDate)} to ${formatDate(combined.endDate)}`,
      monthCount: combined.monthCount,
    },
    transactions: transactions.map(txn => ({
      date: txn.date,
      description: txn.description,
      rawAmount: parseFloat(txn.rawAmount),
      normalizedAmount: parseFloat(txn.normalizedAmount),
      absAmount: parseFloat(txn.absAmount),
      source: txn.source,
      category: txn.category,
      bucket: txn.bucket,
      sourceFile: txn.upload?.filename || `Upload ${txn.uploadId}`,
      uploadId: txn.uploadId,
    })),
  };
}

module.exports = {
  combineUploads,
  getCombinedDetails,
  getCombinedTransactions,
};
